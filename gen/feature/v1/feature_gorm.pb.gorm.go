package rolev1

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/v2/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	v1 "github.com/sandisuryadi36/sansan-dashboard/gen/role/v1"
	v12 "github.com/sandisuryadi36/sansan-dashboard/gen/transaction/v1"
	v11 "github.com/sandisuryadi36/sansan-dashboard/gen/user/v1"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	gorm "gorm.io/gorm"
	strings "strings"
	time "time"
)

type ServiceORM struct {
	CratedAt           *time.Time
	DeletedAt          *time.Time
	Id                 uint64        `gorm:"primaryKey;not null"`
	Roles              []*v1.RoleORM `gorm:"foreignKey:Id;references:Id;many2many:service_roles;joinForeignKey:ServiceId;joinReferences:RoleId"`
	ServiceDescription string
	ServiceName        string
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceORM) TableName() string {
	return "services"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Service) ToORM(ctx context.Context) (ServiceORM, error) {
	to := ServiceORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ServiceName = m.ServiceName
	to.ServiceDescription = m.ServiceDescription
	for _, v := range m.Roles {
		if v != nil {
			if tempRoles, cErr := v.ToORM(ctx); cErr == nil {
				to.Roles = append(to.Roles, &tempRoles)
			} else {
				return to, cErr
			}
		} else {
			to.Roles = append(to.Roles, nil)
		}
	}
	if m.CratedAt != nil {
		t := m.CratedAt.AsTime()
		to.CratedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(ServiceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceORM) ToPB(ctx context.Context) (Service, error) {
	to := Service{}
	var err error
	if prehook, ok := interface{}(m).(ServiceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ServiceName = m.ServiceName
	to.ServiceDescription = m.ServiceDescription
	for _, v := range m.Roles {
		if v != nil {
			if tempRoles, cErr := v.ToPB(ctx); cErr == nil {
				to.Roles = append(to.Roles, &tempRoles)
			} else {
				return to, cErr
			}
		} else {
			to.Roles = append(to.Roles, nil)
		}
	}
	if m.CratedAt != nil {
		to.CratedAt = timestamppb.New(*m.CratedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(ServiceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Service the arg will be the target, the caller the one being converted from

// ServiceBeforeToORM called before default ToORM code
type ServiceWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceORM) error
}

// ServiceAfterToORM called after default ToORM code
type ServiceWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceORM) error
}

// ServiceBeforeToPB called before default ToPB code
type ServiceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Service) error
}

// ServiceAfterToPB called after default ToPB code
type ServiceWithAfterToPB interface {
	AfterToPB(context.Context, *Service) error
}

type FeatureORM struct {
	CratedAt           *time.Time
	DeletedAt          *time.Time
	FeatureDescription string
	FeatureName        string
	Id                 uint64 `gorm:"primaryKey;not null"`
	IsDefault          bool
	Service            *ServiceORM `gorm:"foreignKey:ServiceId;references:Id"`
	ServiceId          *uint64
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (FeatureORM) TableName() string {
	return "features"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Feature) ToORM(ctx context.Context) (FeatureORM, error) {
	to := FeatureORM{}
	var err error
	if prehook, ok := interface{}(m).(FeatureWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FeatureName = m.FeatureName
	to.FeatureDescription = m.FeatureDescription
	if m.Service != nil {
		tempService, err := m.Service.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Service = &tempService
	}
	to.IsDefault = m.IsDefault
	if m.CratedAt != nil {
		t := m.CratedAt.AsTime()
		to.CratedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(FeatureWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeatureORM) ToPB(ctx context.Context) (Feature, error) {
	to := Feature{}
	var err error
	if prehook, ok := interface{}(m).(FeatureWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FeatureName = m.FeatureName
	to.FeatureDescription = m.FeatureDescription
	if m.Service != nil {
		tempService, err := m.Service.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Service = &tempService
	}
	to.IsDefault = m.IsDefault
	if m.CratedAt != nil {
		to.CratedAt = timestamppb.New(*m.CratedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(FeatureWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Feature the arg will be the target, the caller the one being converted from

// FeatureBeforeToORM called before default ToORM code
type FeatureWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeatureORM) error
}

// FeatureAfterToORM called after default ToORM code
type FeatureWithAfterToORM interface {
	AfterToORM(context.Context, *FeatureORM) error
}

// FeatureBeforeToPB called before default ToPB code
type FeatureWithBeforeToPB interface {
	BeforeToPB(context.Context, *Feature) error
}

// FeatureAfterToPB called after default ToPB code
type FeatureWithAfterToPB interface {
	AfterToPB(context.Context, *Feature) error
}

type UserExtraFeatureORM struct {
	CratedAt             *time.Time
	DeletedAt            *time.Time
	Feature              *FeatureORM `gorm:"foreignKey:FeatureId;references:Id"`
	FeatureId            *uint64
	FeatureTransaction   *FeatureTransactionORM `gorm:"foreignKey:FeatureTransactionId;references:Id"`
	FeatureTransactionId *uint64
	Id                   uint64 `gorm:"primaryKey;not null"`
	UpdatedAt            *time.Time
	User                 *v11.UserORM `gorm:"foreignKey:UserId;references:Id"`
	UserId               *uint64
}

// TableName overrides the default tablename generated by GORM
func (UserExtraFeatureORM) TableName() string {
	return "user_extra_features"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserExtraFeature) ToORM(ctx context.Context) (UserExtraFeatureORM, error) {
	to := UserExtraFeatureORM{}
	var err error
	if prehook, ok := interface{}(m).(UserExtraFeatureWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.User != nil {
		tempUser, err := m.User.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	if m.Feature != nil {
		tempFeature, err := m.Feature.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Feature = &tempFeature
	}
	if m.FeatureTransaction != nil {
		tempFeatureTransaction, err := m.FeatureTransaction.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.FeatureTransaction = &tempFeatureTransaction
	}
	if m.CratedAt != nil {
		t := m.CratedAt.AsTime()
		to.CratedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(UserExtraFeatureWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserExtraFeatureORM) ToPB(ctx context.Context) (UserExtraFeature, error) {
	to := UserExtraFeature{}
	var err error
	if prehook, ok := interface{}(m).(UserExtraFeatureWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.User != nil {
		tempUser, err := m.User.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	if m.Feature != nil {
		tempFeature, err := m.Feature.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Feature = &tempFeature
	}
	if m.FeatureTransaction != nil {
		tempFeatureTransaction, err := m.FeatureTransaction.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.FeatureTransaction = &tempFeatureTransaction
	}
	if m.CratedAt != nil {
		to.CratedAt = timestamppb.New(*m.CratedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(UserExtraFeatureWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserExtraFeature the arg will be the target, the caller the one being converted from

// UserExtraFeatureBeforeToORM called before default ToORM code
type UserExtraFeatureWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserExtraFeatureORM) error
}

// UserExtraFeatureAfterToORM called after default ToORM code
type UserExtraFeatureWithAfterToORM interface {
	AfterToORM(context.Context, *UserExtraFeatureORM) error
}

// UserExtraFeatureBeforeToPB called before default ToPB code
type UserExtraFeatureWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserExtraFeature) error
}

// UserExtraFeatureAfterToPB called after default ToPB code
type UserExtraFeatureWithAfterToPB interface {
	AfterToPB(context.Context, *UserExtraFeature) error
}

type FeatureTransactionORM struct {
	CratedAt          *time.Time
	DeletedAt         *time.Time
	ExpiredDate       *time.Time
	Feature           *FeatureORM `gorm:"foreignKey:FeatureId;references:Id"`
	FeatureId         *uint64
	Id                uint64 `gorm:"primaryKey;not null"`
	UpdatedAt         *time.Time
	UserTransaction   *v12.UserTransactionORM `gorm:"foreignKey:UserTransactionId;references:Id"`
	UserTransactionId *uint64
}

// TableName overrides the default tablename generated by GORM
func (FeatureTransactionORM) TableName() string {
	return "feature_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FeatureTransaction) ToORM(ctx context.Context) (FeatureTransactionORM, error) {
	to := FeatureTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(FeatureTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.UserTransaction != nil {
		tempUserTransaction, err := m.UserTransaction.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.UserTransaction = &tempUserTransaction
	}
	if m.Feature != nil {
		tempFeature, err := m.Feature.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Feature = &tempFeature
	}
	if m.ExpiredDate != nil {
		t := m.ExpiredDate.AsTime()
		to.ExpiredDate = &t
	}
	if m.CratedAt != nil {
		t := m.CratedAt.AsTime()
		to.CratedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(FeatureTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeatureTransactionORM) ToPB(ctx context.Context) (FeatureTransaction, error) {
	to := FeatureTransaction{}
	var err error
	if prehook, ok := interface{}(m).(FeatureTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.UserTransaction != nil {
		tempUserTransaction, err := m.UserTransaction.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.UserTransaction = &tempUserTransaction
	}
	if m.Feature != nil {
		tempFeature, err := m.Feature.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Feature = &tempFeature
	}
	if m.ExpiredDate != nil {
		to.ExpiredDate = timestamppb.New(*m.ExpiredDate)
	}
	if m.CratedAt != nil {
		to.CratedAt = timestamppb.New(*m.CratedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(FeatureTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FeatureTransaction the arg will be the target, the caller the one being converted from

// FeatureTransactionBeforeToORM called before default ToORM code
type FeatureTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeatureTransactionORM) error
}

// FeatureTransactionAfterToORM called after default ToORM code
type FeatureTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *FeatureTransactionORM) error
}

// FeatureTransactionBeforeToPB called before default ToPB code
type FeatureTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *FeatureTransaction) error
}

// FeatureTransactionAfterToPB called after default ToPB code
type FeatureTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *FeatureTransaction) error
}

// DefaultCreateService executes a basic gorm create call
func DefaultCreateService(ctx context.Context, in *Service, db *gorm.DB) (*Service, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ServiceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadService(ctx context.Context, in *Service, db *gorm.DB) (*Service, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ServiceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ServiceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteService(ctx context.Context, in *Service, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ServiceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteServiceSet(ctx context.Context, in []*Service, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceORM{})).(ServiceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceORM{})).(ServiceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Service, *gorm.DB) (*gorm.DB, error)
}
type ServiceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Service, *gorm.DB) error
}

// DefaultStrictUpdateService clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateService(ctx context.Context, in *Service, db *gorm.DB) (*Service, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateService")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Model(&ormObj).Association("Roles").Replace(ormObj.Roles); err != nil {
		return nil, err
	}
	ormObj.Roles = nil
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ServiceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ServiceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchService executes a basic gorm update call with patch behavior
func DefaultPatchService(ctx context.Context, in *Service, updateMask *field_mask.FieldMask, db *gorm.DB) (*Service, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Service
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadService(ctx, &Service{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskService(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateService(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Service, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ServiceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Service, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ServiceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Service, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ServiceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Service, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetService executes a bulk gorm update call with patch behavior
func DefaultPatchSetService(ctx context.Context, objects []*Service, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Service, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Service, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchService(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskService patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskService(ctx context.Context, patchee *Service, patcher *Service, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Service, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCratedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ServiceName" {
			patchee.ServiceName = patcher.ServiceName
			continue
		}
		if f == prefix+"ServiceDescription" {
			patchee.ServiceDescription = patcher.ServiceDescription
			continue
		}
		if f == prefix+"Roles" {
			patchee.Roles = patcher.Roles
			continue
		}
		if !updatedCratedAt && strings.HasPrefix(f, prefix+"CratedAt.") {
			if patcher.CratedAt == nil {
				patchee.CratedAt = nil
				continue
			}
			if patchee.CratedAt == nil {
				patchee.CratedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CratedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CratedAt, patchee.CratedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CratedAt" {
			updatedCratedAt = true
			patchee.CratedAt = patcher.CratedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListService executes a gorm list call
func DefaultListService(ctx context.Context, db *gorm.DB) ([]*Service, error) {
	in := Service{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Service{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ServiceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ServiceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ServiceORM) error
}

// DefaultCreateFeature executes a basic gorm create call
func DefaultCreateFeature(ctx context.Context, in *Feature, db *gorm.DB) (*Feature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeatureORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFeature(ctx context.Context, in *Feature, db *gorm.DB) (*Feature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeatureORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeatureORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeatureORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFeature(ctx context.Context, in *Feature, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeatureORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeatureORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFeatureSet(ctx context.Context, in []*Feature, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeatureORM{})).(FeatureORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeatureORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeatureORM{})).(FeatureORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeatureORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Feature, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Feature, *gorm.DB) error
}

// DefaultStrictUpdateFeature clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeature(ctx context.Context, in *Feature, db *gorm.DB) (*Feature, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeature")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeatureORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeatureORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFeature executes a basic gorm update call with patch behavior
func DefaultPatchFeature(ctx context.Context, in *Feature, updateMask *field_mask.FieldMask, db *gorm.DB) (*Feature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Feature
	var err error
	if hook, ok := interface{}(&pbObj).(FeatureWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeature(ctx, &Feature{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeatureWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeature(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeatureWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeature(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeatureWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeatureWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Feature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FeatureWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Feature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FeatureWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Feature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FeatureWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Feature, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFeature executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeature(ctx context.Context, objects []*Feature, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Feature, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Feature, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeature(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeature patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeature(ctx context.Context, patchee *Feature, patcher *Feature, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Feature, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedService bool
	var updatedCratedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"FeatureName" {
			patchee.FeatureName = patcher.FeatureName
			continue
		}
		if f == prefix+"FeatureDescription" {
			patchee.FeatureDescription = patcher.FeatureDescription
			continue
		}
		if !updatedService && strings.HasPrefix(f, prefix+"Service.") {
			updatedService = true
			if patcher.Service == nil {
				patchee.Service = nil
				continue
			}
			if patchee.Service == nil {
				patchee.Service = &Service{}
			}
			if o, err := DefaultApplyFieldMaskService(ctx, patchee.Service, patcher.Service, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Service.", db); err != nil {
				return nil, err
			} else {
				patchee.Service = o
			}
			continue
		}
		if f == prefix+"Service" {
			updatedService = true
			patchee.Service = patcher.Service
			continue
		}
		if f == prefix+"IsDefault" {
			patchee.IsDefault = patcher.IsDefault
			continue
		}
		if !updatedCratedAt && strings.HasPrefix(f, prefix+"CratedAt.") {
			if patcher.CratedAt == nil {
				patchee.CratedAt = nil
				continue
			}
			if patchee.CratedAt == nil {
				patchee.CratedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CratedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CratedAt, patchee.CratedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CratedAt" {
			updatedCratedAt = true
			patchee.CratedAt = patcher.CratedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeature executes a gorm list call
func DefaultListFeature(ctx context.Context, db *gorm.DB) ([]*Feature, error) {
	in := Feature{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeatureORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Feature{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeatureORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FeatureORM) error
}

// DefaultCreateUserExtraFeature executes a basic gorm create call
func DefaultCreateUserExtraFeature(ctx context.Context, in *UserExtraFeature, db *gorm.DB) (*UserExtraFeature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserExtraFeatureORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserExtraFeature(ctx context.Context, in *UserExtraFeature, db *gorm.DB) (*UserExtraFeature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserExtraFeatureORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserExtraFeatureORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserExtraFeatureORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserExtraFeature(ctx context.Context, in *UserExtraFeature, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserExtraFeatureORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserExtraFeatureORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserExtraFeatureSet(ctx context.Context, in []*UserExtraFeature, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserExtraFeatureORM{})).(UserExtraFeatureORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserExtraFeatureORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserExtraFeatureORM{})).(UserExtraFeatureORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserExtraFeatureORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserExtraFeature, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserExtraFeature, *gorm.DB) error
}

// DefaultStrictUpdateUserExtraFeature clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserExtraFeature(ctx context.Context, in *UserExtraFeature, db *gorm.DB) (*UserExtraFeature, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserExtraFeature")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserExtraFeatureORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserExtraFeatureORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserExtraFeature executes a basic gorm update call with patch behavior
func DefaultPatchUserExtraFeature(ctx context.Context, in *UserExtraFeature, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserExtraFeature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserExtraFeature
	var err error
	if hook, ok := interface{}(&pbObj).(UserExtraFeatureWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserExtraFeature(ctx, &UserExtraFeature{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserExtraFeatureWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserExtraFeature(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserExtraFeatureWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserExtraFeature(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserExtraFeatureWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserExtraFeatureWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserExtraFeature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserExtraFeature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserExtraFeature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserExtraFeature, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserExtraFeature executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserExtraFeature(ctx context.Context, objects []*UserExtraFeature, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserExtraFeature, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserExtraFeature, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserExtraFeature(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserExtraFeature patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserExtraFeature(ctx context.Context, patchee *UserExtraFeature, patcher *UserExtraFeature, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserExtraFeature, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedUser bool
	var updatedFeature bool
	var updatedFeatureTransaction bool
	var updatedCratedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedUser && strings.HasPrefix(f, prefix+"User.") {
			updatedUser = true
			if patcher.User == nil {
				patchee.User = nil
				continue
			}
			if patchee.User == nil {
				patchee.User = &v11.User{}
			}
			if o, err := v11.DefaultApplyFieldMaskUser(ctx, patchee.User, patcher.User, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"User.", db); err != nil {
				return nil, err
			} else {
				patchee.User = o
			}
			continue
		}
		if f == prefix+"User" {
			updatedUser = true
			patchee.User = patcher.User
			continue
		}
		if !updatedFeature && strings.HasPrefix(f, prefix+"Feature.") {
			updatedFeature = true
			if patcher.Feature == nil {
				patchee.Feature = nil
				continue
			}
			if patchee.Feature == nil {
				patchee.Feature = &Feature{}
			}
			if o, err := DefaultApplyFieldMaskFeature(ctx, patchee.Feature, patcher.Feature, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Feature.", db); err != nil {
				return nil, err
			} else {
				patchee.Feature = o
			}
			continue
		}
		if f == prefix+"Feature" {
			updatedFeature = true
			patchee.Feature = patcher.Feature
			continue
		}
		if !updatedFeatureTransaction && strings.HasPrefix(f, prefix+"FeatureTransaction.") {
			updatedFeatureTransaction = true
			if patcher.FeatureTransaction == nil {
				patchee.FeatureTransaction = nil
				continue
			}
			if patchee.FeatureTransaction == nil {
				patchee.FeatureTransaction = &FeatureTransaction{}
			}
			if o, err := DefaultApplyFieldMaskFeatureTransaction(ctx, patchee.FeatureTransaction, patcher.FeatureTransaction, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"FeatureTransaction.", db); err != nil {
				return nil, err
			} else {
				patchee.FeatureTransaction = o
			}
			continue
		}
		if f == prefix+"FeatureTransaction" {
			updatedFeatureTransaction = true
			patchee.FeatureTransaction = patcher.FeatureTransaction
			continue
		}
		if !updatedCratedAt && strings.HasPrefix(f, prefix+"CratedAt.") {
			if patcher.CratedAt == nil {
				patchee.CratedAt = nil
				continue
			}
			if patchee.CratedAt == nil {
				patchee.CratedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CratedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CratedAt, patchee.CratedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CratedAt" {
			updatedCratedAt = true
			patchee.CratedAt = patcher.CratedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserExtraFeature executes a gorm list call
func DefaultListUserExtraFeature(ctx context.Context, db *gorm.DB) ([]*UserExtraFeature, error) {
	in := UserExtraFeature{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserExtraFeatureORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserExtraFeatureORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserExtraFeature{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserExtraFeatureORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserExtraFeatureORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserExtraFeatureORM) error
}

// DefaultCreateFeatureTransaction executes a basic gorm create call
func DefaultCreateFeatureTransaction(ctx context.Context, in *FeatureTransaction, db *gorm.DB) (*FeatureTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeatureTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFeatureTransaction(ctx context.Context, in *FeatureTransaction, db *gorm.DB) (*FeatureTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeatureTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeatureTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeatureTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFeatureTransaction(ctx context.Context, in *FeatureTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeatureTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeatureTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFeatureTransactionSet(ctx context.Context, in []*FeatureTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeatureTransactionORM{})).(FeatureTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeatureTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeatureTransactionORM{})).(FeatureTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeatureTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FeatureTransaction, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FeatureTransaction, *gorm.DB) error
}

// DefaultStrictUpdateFeatureTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeatureTransaction(ctx context.Context, in *FeatureTransaction, db *gorm.DB) (*FeatureTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeatureTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeatureTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeatureTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFeatureTransaction executes a basic gorm update call with patch behavior
func DefaultPatchFeatureTransaction(ctx context.Context, in *FeatureTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*FeatureTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FeatureTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(FeatureTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeatureTransaction(ctx, &FeatureTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeatureTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeatureTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeatureTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeatureTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeatureTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeatureTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FeatureTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FeatureTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FeatureTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FeatureTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFeatureTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeatureTransaction(ctx context.Context, objects []*FeatureTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FeatureTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FeatureTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeatureTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeatureTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeatureTransaction(ctx context.Context, patchee *FeatureTransaction, patcher *FeatureTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FeatureTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedUserTransaction bool
	var updatedFeature bool
	var updatedExpiredDate bool
	var updatedCratedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedUserTransaction && strings.HasPrefix(f, prefix+"UserTransaction.") {
			updatedUserTransaction = true
			if patcher.UserTransaction == nil {
				patchee.UserTransaction = nil
				continue
			}
			if patchee.UserTransaction == nil {
				patchee.UserTransaction = &v12.UserTransaction{}
			}
			if o, err := v12.DefaultApplyFieldMaskUserTransaction(ctx, patchee.UserTransaction, patcher.UserTransaction, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"UserTransaction.", db); err != nil {
				return nil, err
			} else {
				patchee.UserTransaction = o
			}
			continue
		}
		if f == prefix+"UserTransaction" {
			updatedUserTransaction = true
			patchee.UserTransaction = patcher.UserTransaction
			continue
		}
		if !updatedFeature && strings.HasPrefix(f, prefix+"Feature.") {
			updatedFeature = true
			if patcher.Feature == nil {
				patchee.Feature = nil
				continue
			}
			if patchee.Feature == nil {
				patchee.Feature = &Feature{}
			}
			if o, err := DefaultApplyFieldMaskFeature(ctx, patchee.Feature, patcher.Feature, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Feature.", db); err != nil {
				return nil, err
			} else {
				patchee.Feature = o
			}
			continue
		}
		if f == prefix+"Feature" {
			updatedFeature = true
			patchee.Feature = patcher.Feature
			continue
		}
		if !updatedExpiredDate && strings.HasPrefix(f, prefix+"ExpiredDate.") {
			if patcher.ExpiredDate == nil {
				patchee.ExpiredDate = nil
				continue
			}
			if patchee.ExpiredDate == nil {
				patchee.ExpiredDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ExpiredDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ExpiredDate, patchee.ExpiredDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ExpiredDate" {
			updatedExpiredDate = true
			patchee.ExpiredDate = patcher.ExpiredDate
			continue
		}
		if !updatedCratedAt && strings.HasPrefix(f, prefix+"CratedAt.") {
			if patcher.CratedAt == nil {
				patchee.CratedAt = nil
				continue
			}
			if patchee.CratedAt == nil {
				patchee.CratedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CratedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CratedAt, patchee.CratedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CratedAt" {
			updatedCratedAt = true
			patchee.CratedAt = patcher.CratedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeatureTransaction executes a gorm list call
func DefaultListFeatureTransaction(ctx context.Context, db *gorm.DB) ([]*FeatureTransaction, error) {
	in := FeatureTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeatureTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FeatureTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeatureTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FeatureTransactionORM) error
}
